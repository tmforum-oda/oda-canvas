// const { Middleware } = require('swagger-express-middleware')
const http = require('http')
const fs = require('fs')
const path = require('path')
const swaggerUI = require('swagger-ui-express')
const jsYaml = require('js-yaml')
const express = require('express')
const cors = require('cors')
const cookieParser = require('cookie-parser')
const bodyParser = require('body-parser')
const OpenApiValidator = require('express-openapi-validator')
const logger = require('./logger')
const config = require('./config')

const { getBasePath } = require('./utils/swaggerUtils')
const { updateAPISpecification } = require('./utils/fixes')

const { entrypoint } = require('./utils/entrypoint')

const cleanPath = (path) => path.replace(/\/\//,'/')

class ExpressServer {
  constructor(port, openApiYaml) {
    this.port = port;
    this.app = express();
    this.openApiPath = openApiYaml;
    try {
    
      this.schema = jsYaml.safeLoad(fs.readFileSync(openApiYaml))
      
      updateAPISpecification(this.schema, openApiYaml)

    } catch (e) {
      logger.error('failed to start TMF639 Resource Inventory Express Server', e.message)
    }

    this.setupMiddleware()
  
  }

  setupMiddleware() {

    const basePath = getBasePath().replace(/\/$/,'')
    logger.info(`TMF639 Resource Inventory basePath: ${basePath}`)
    
    // this.setupAllowedMedia();
    this.app.use(cors())
    // this.app.use(bodyParser.json({ limit: '14MB' }))
    this.app.use(express.json())
    this.app.use(express.text())
    this.app.use(express.urlencoded({ extended: false }))
    
    // Configure query parser to handle special characters in filter parameters
    this.app.set('query parser', (str) => {
      // Custom query parser that preserves filter parameters
      const params = new URLSearchParams(str);
      const result = {};
      for (const [key, value] of params.entries()) {
        // Don't decode filter parameters automatically
        if (key === 'filter') {
          result[key] = value; // Keep original value
        } else {
          result[key] = decodeURIComponent(value);
        }
      }
      return result;
    })
    this.app.use(cookieParser())
    
    //Simple test to see that the server is up and responding
    this.app.get('/hello', (req, res) => res.send(`Hello World. TMF639 Resource Inventory - path: ${this.openApiPath}`))
    
    const openapi=config.OPENAPI || '/openapi'

    //Send the openapi document *AS GENERATED BY THE GENERATOR*
    this.app.get(cleanPath(`${basePath}${openapi}`), (req, res) => res.sendFile((path.join(__dirname, 'api', 'TMF639-Resource_Inventory_Management-v5.0.0.oas.yaml'))))

    //View the openapi document in a visual interface. Should be able to test from this page
    this.app.use(cleanPath(`${basePath}/api-docs`), swaggerUI.serve, swaggerUI.setup(this.schema))

    this.app.get('/login-redirect', (req, res) => {
      res.status(200)
      res.json(req.query)
    })

    this.app.get('/oauth2-redirect.html', (req, res) => {
      res.status(200)
      res.json(req.query)
    })
    
    this.app.get(`${openapi}`, function(req, res) {
      res.redirect(cleanPath(`${basePath}/${openapi}`))
    })

    this.app.get('/api-docs', function(req, res) {
      res.redirect(cleanPath(`${basePath}/api-docs`))
    })

    this.app.use(cleanPath(`${basePath}/entrypoint`), entrypoint)

    this.app.get('/', function(req, res) {
      res.redirect(cleanPath(`${basePath}/entrypoint`))
    })

    this.app.get(cleanPath(`${basePath}/`), function(req, res) {
      res.redirect(cleanPath(`${basePath}/entrypoint`))
    })

    const apiTimeout = 5 * 1000
    if(false) this.app.use((req, res, next) => {
        // Set the timeout for all responses
        res.setTimeout(apiTimeout, () => {
            let err = new Error('Service Unavailable')
            err.status = 503
            next(err)
        })
    })
}

  launch() {
    try {
      
      const SOURCE_DATE_EPOCH = process.env.SOURCE_DATE_EPOCH
      const GIT_COMMIT_SHA = process.env.GIT_COMMIT_SHA
      const CICD_BUILD_TIME = process.env.CICD_BUILD_TIME
      if (SOURCE_DATE_EPOCH) {
          logger.info(`SOURCE_DATE_EPOCH=${SOURCE_DATE_EPOCH}`)
      }
      if (GIT_COMMIT_SHA) {
          logger.info(`GIT_COMMIT_SHA=${GIT_COMMIT_SHA}`)
      }      if (CICD_BUILD_TIME) {
          logger.info(`CICD_BUILD_TIME=${CICD_BUILD_TIME}`)      }        
      
      // Add middleware to log all requests for debugging
        this.app.use((req, res, next) => {
          logger.info(`Request: ${req.method} ${req.path} - URL: ${req.url}`)
          next()
        });
          logger.info('Loading OpenApiValidator with apiSpec:', this.openApiPath);
        
      // Create a router for TMF639 basepath
      const tmfRouter = express.Router();
      
      // Pre-processing middleware to handle unencoded filter parameters
      tmfRouter.use((req, res, next) => {
        console.log('Pre-validation middleware - Original filter:', req.query.filter);
        console.log('Pre-validation middleware - URL:', req.url);
        console.log('Pre-validation middleware - Query:', JSON.stringify(req.query));
        
        // If filter parameter contains special characters, temporarily encode it for validation
        if (req.query.filter && (req.query.filter.includes('$') || req.query.filter.includes('[') || req.query.filter.includes('(') || req.query.filter.includes('@'))) {
          console.log('Pre-validation middleware - Found special characters, encoding filter');
          // Store the original filter value
          req.originalFilterValue = req.query.filter;
          // Temporarily encode it for the validator
          req.query.filter = encodeURIComponent(req.query.filter);
          console.log('Pre-validation middleware - Encoded filter:', req.query.filter);
        }
        next();
      });
      
      // OpenAPI Validator with allowReserved support for filter parameters
      tmfRouter.use(OpenApiValidator.middleware({
        apiSpec: this.openApiPath,
        validateRequests: true,
        validateResponses: true,
        unknownFormats: ['base64']
      }));
      
      // Post-validation middleware to restore original filter value
      tmfRouter.use((req, res, next) => {
        // Restore the original filter value after validation
        if (req.originalFilterValue) {
          req.query.filter = req.originalFilterValue;
          delete req.originalFilterValue;
        }
        next();
      });
      const controllers = require('./controllers');
      tmfRouter.get('/resource', controllers.ResourceController.listResource);
      tmfRouter.get('/resource/:id', controllers.ResourceController.retrieveResource);
      // Error handler for router
      tmfRouter.use((err, req, res, next) => {
        res.status(err.status || 500).json({
          message: err.message || err,
          errors: err.errors || '',
        });
      });
      // Mount the router at the TMF639 basepath
      this.app.use('/tmf-api/resourceInventoryManagement/v5', tmfRouter);
      logger.info(`TMF639 Resource Inventory validator installed`)
  
      this.app.use((err, req, res, next) => {
        // format errors
        res.status(err.status || 500).json({
          message: err.message || err,
          errors: err.errors || '',
        })
      })

      const server = http.createServer(this.app)
      server.listen(this.port)

      logger.info(`TMF639 Resource Inventory listening on port ${this.port}`)
       
    } catch(e) {
        logger.info(`TMF639 Resource Inventory launch error: ` + e)
    }

  }


  async close() {
    if (this.server !== undefined) {
      await this.server.close();
      logger.info(`TMF639 Resource Inventory server on port ${this.port} shut down`)
    }
  }
}

module.exports = ExpressServer;
